---
import BaseLayout from "../layouts/BaseLayout.astro";
---

<BaseLayout title="Friends">
  <h2>Friends</h2>
  <p>Shoutouts to these awesome people. They all rock.</p>
  <p>
    It needs to be said - this is a non-exhaustive list. I can't think of
    everyone let alone fit them all, no IRLs.
  </p>

  <div id="canvas"></div>
</BaseLayout>

<script>
  import * as mg from "mingine-engine";
  import frens from "../frens.json";

  for (let i = frens.n.length - 1; i > 0; i--) {
    const j = ~~(Math.random() * (i + 1));
    [frens.n[i], frens.n[j]] = [frens.n[j], frens.n[i]];
  }

  const PROFILE_PICTURE_RADIUS = 0.1; // m
  const MAX_CANVAS_SIZE = 600; // px
  const ROTATION_SPEED = 0.025 * 2 * Math.PI; // rad / s
  const SPRING_CONSTANT = 4; // N / m
  const RADIUS = 0.35; // m
  const REPULSION_STREGTH = .1;
  const REPULSION_MAX = 10;

  let mousePos : mg.Vec2 | undefined;

  // implementation of the profile pic object

  const createProfilePic = (id: string, initRot: number, img: string, col: string) => {
    let rotation = initRot;

    const circle = mg.createCircle({
      id,
      radius: PROFILE_PICTURE_RADIUS, // m
      momentOfInertia: 0, // this is ignored anyway
      mass: 1, // kg

      angle: 0,
      angVelocity: 0,
      angAccel: 0,

      styles: {
        border: `3px solid ${col}`,
        "border-radius": "999px",
        "box-sizing": "border-box",
        background: col,//`url(${img})`,
        "background-size": "contain"
      },

      forces: [
        (simulation) => {
          const [, tStep] = simulation;

          rotation += tStep * ROTATION_SPEED;

          // we have to construct a new force model every time as we change the target position
          // Mingine models are stable and un-stateful and so this should work just fine
          return mg.forceModels.spring(
            SPRING_CONSTANT,
            // @ts-expect-error I forgot to put vAngle in the type defs
            mg.vAngle(rotation, RADIUS),
            mg.vo()
          )(simulation);
        },

        ([physObj]) => {
          if (!mousePos) return [mg.vo(), 0];
          console.log(mousePos);

          const relativePos = physObj.pos.sub(mousePos);
          const amount = Math.min(REPULSION_STREGTH / relativePos.len(), REPULSION_MAX);
          return [relativePos.norm().scale(amount), 0];
        },

        mg.forceModels.simpleDamping(2, 1),
      ],
    });

    circle.physicsObj.momentOfInertia = Infinity; // rotation is impossible - mingine bug :(
    return circle;
  };

  // construct engine
  const engine = mg.createEngine(
    mg.createScene({
      // canvas from -1/2 to 1/2
      canvasSize: mg.v(1, 1),
      renderOffset: mg.v(-0.5, -0.5),
      scale: 1,

      objects: [
        ...[frens.s, ...frens.n].map((fren, i) => createProfilePic(`fren_${i}`, 2 * Math.PI * i / frens.n.length, fren[0], fren[1]))
      ]
    })
  );
  engine.mount(document.getElementById("canvas")!);

  engine.start({ lockPhysicsToRender: true });
  window["engine"] = engine;

  // resize observer
  const wrap = document.getElementById("canvas")!;
  const fix = () => {
      engine.scene.scale = Math.min(wrap.clientWidth, MAX_CANVAS_SIZE)

      for (const o of engine.scene.getObjects()) {
        const s = o.styles as any;
        s.width = s.height = engine.scene.scale * PROFILE_PICTURE_RADIUS * 2 + "px";
      }
    };
  new ResizeObserver(fix).observe(wrap);

  wrap.onmousemove = (ev) => {
    const bounds = wrap.getBoundingClientRect();
    mousePos = mg.v(ev.x - bounds.left, bounds.height - (ev.y - bounds.top)).scdiv(bounds.height).sub(mg.v(0.5, 0.5));
  }
  wrap.onmouseleave = () => mousePos = undefined;
</script>

<style lang="sass">
  #canvas
    max-width: 600px
    margin: 0 auto
    border: red 1px solid
    width: unset !important
</style>
